diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
index 1ebc924..a7f60de 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
@@ -39,7 +39,7 @@ interface TimeBarConfig extends IPluginBaseConfig {
     readonly containerCSS?: Object;
     readonly changeData?: boolean;
     rangeChange?: (graph: IGraph, minValue: string, maxValue: string) => void;
-    getDate?: (d: any) => number;
+    getDate?: (d: any) => number[]; //<------
     getValue?: (d: any) => number;
     shouldIgnore?: (itemType: 'node' | 'edge', model: any, dateRage: {
         min: number;
diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.js b/node_modules/@antv/g6-plugin/es/timeBar/index.js
index b07b81f..0b2ae54 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.js
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.js
@@ -101,7 +101,7 @@ var TimeBar = /** @class */function (_super) {
       },
       textStyle: {},
       filterEdge: false,
-      filterItemTypes: ['node'],
+      filterItemTypes: [/* 'node',  */'edge'], /* remove node,  added 'edge' */
       containerCSS: {}
     };
   };
@@ -269,6 +269,21 @@ var TimeBar = /** @class */function (_super) {
     });
     this.set('timebar', timebar);
   };
+
+  function getAllNodesInCombo(combo) {  // ---ADDED
+    let arr = []; // ---ADDED
+    return grabAllNodes(combo, arr); // ---ADDED 
+  }
+
+  function grabAllNodes(combo, array) { // ---ADDED
+    let combos = combo.getCombos();  // ---ADDED
+    let childNodes = combo.getNodes();  // ---ADDED
+    
+    combos.forEach((inCombo) => { array.concat(grabAllNodes(inCombo, array)); }); // ---ADDED
+    childNodes.forEach((node) => { array.push(node); }); // ---ADDED
+    return array;
+  }
+
   TimeBar.prototype.filterData = function (evt) {
     var _a;
     var value = evt.value;
@@ -331,7 +346,8 @@ var TimeBar = /** @class */function (_super) {
           return currentNodeExistMap_1[node.getID()] = true; 
         });
         graph.getEdges().forEach(function (edge) {
-          return currentEdgeExistMap_1[edge.getID()] = true;
+          return currentEdgeExistMap_1[edge.getID()] = edge.isVisible(); // <================ ADDED
+          // return currentEdgeExistMap_1[edge.getID()] = true; // <=================NOT USED
         });
         if (filterItemTypes.includes('node')) {
           originNodes === null || originNodes === void 0 ? void 0 : originNodes.forEach(function (node) {
@@ -342,10 +358,16 @@ var TimeBar = /** @class */function (_super) {
             }));
             var exist = currentNodeExistMap_1[node.id];
             if (exist && !hitRange) {
+              //*** Save the node comboID ***//
+              const comboID = node.comboId; //<=== added
               graph.removeItem(node.id);
+              //***Append back the comboID back to node***//
+              console.log('node removed!:', node); //<=== added
+              node.comboId = comboID; //<=== added
               currentNodeExistMap_1[node.id] = false;
             } else if (!exist && hitRange) {
               graph.addItem('node', node);
+              console.log('node added back:', node); //<=== added
               currentNodeExistMap_1[node.id] = true;
             }
           });
@@ -370,23 +392,120 @@ var TimeBar = /** @class */function (_super) {
         if (this.get('filterEdge') || filterItemTypes.includes('edge')) {
           originEdges === null || originEdges === void 0 ? void 0 : originEdges.filter(function (edge) {
             var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
-            var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
+            const dates = edge.date; // <---- ADDED
+            const dateHit = dates.some((date) => (date >= minDate_1 && date <= maxDate_1)); // <---- ADDED
+            var hitRange = /* date >= minDate_1 && date <= maxDate_1 */ dateHit || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
               min: minDate_1,
               max: maxDate_1
             }));
+            const hitDates = []; // <---- ADDED
+            edge.date.forEach((date) => { // <---- ADDED
+              if(date >= minDate_1 && date <= maxDate_1) hitDates.push(date); // <---- ADDED
+            }); // <---- ADDED
+            graph.findById(edge.id).getModel().frequency = hitDates.length; // <---- ADDED
+            graph.updateItem(graph.findById(edge.id), { // <---- ADDED
+              frequency: hitDates.length  // <---- ADDED
+            }); // <---- ADDED
+
             var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target];
             var shouldShow = hitRange && endsExist;
             var exist = currentEdgeExistMap_1[edge.id];
             if (exist && !shouldShow) {
               currentEdgeExistMap_1[edge.id] = false;
-              graph.removeItem(edge.id);
+              //graph.removeItem(edge.id);
+              const edgeObject = graph.findById(edge.id);// <---- ADDED
+              graph.hideItem(edgeObject); // <---- change we don't remove the item.
+              edge.inRange = false; // <---- ADDED
+              const source = edgeObject.getSource(); // <---- ADDED
+              const target = edgeObject.getTarget(); // <---- ADDED
+              const sourceEdges = source.getEdges(); // <---- ADDED
+              const targetEdges = target.getEdges(); // <---- ADDED
+              let sourceEdgeScore = 0; // <---- ADDED
+              sourceEdges.forEach((edge) => { // <---- ADDED
+                if(edge.isVisible()) { // <---- ADDED
+                  sourceEdgeScore++; // <---- ADDED
+                } // <---- ADDED
+              }); // <---- ADDED
+              if(sourceEdgeScore === 0){ // <---- ADDED
+                graph.hideItem(source); // <---- ADDED
+                source.getModel().inRange = false // <---- ADDED
+                // update ComboID
+                if (source.getModel().comboId !== undefined) {
+                  const sCombo = graph.findById(source.getModel().comboId);
+                  const nodesInCombo = getAllNodesInCombo(sCombo);
+                  const visibleNodes = nodesInCombo.filter((node) => node.isVisible())
+                  sCombo.getModel().label = visibleNodes.length; 
+                  if(sCombo.getModel().label === 0 && sCombo.isVisible()) {
+                    graph.updateItem(sCombo, { visible: false });
+                    sCombo.getModel().inRange = false;
+                  } else {
+                    graph.updateCombo(sCombo);
+                  }
+                }
+              }
+              let targetEdgeScore = 0; // <---- ADDED
+              targetEdges.forEach((edge) => { // <---- ADDED
+                if(edge.isVisible()) { // <---- ADDED
+                  targetEdgeScore++; // <---- ADDED
+                } // <---- ADDED
+              }); // <---- ADDED
+              if(targetEdgeScore === 0){ // <---- ADDED
+                graph.hideItem(target); // <---- ADDED
+                target.getModel().inRange = false // <---- ADDED
+                if (target.getModel().comboId !== undefined) {
+                  const tCombo = graph.findById(target.getModel().comboId);
+                  const nodesInCombo = getAllNodesInCombo(tCombo);
+                  const visibleNodes = nodesInCombo.filter((node) => node.isVisible())
+                  tCombo.getModel().label = visibleNodes.length; 
+                  if(tCombo.getModel().label === 0 && tCombo.isVisible() ) {
+                    graph.updateItem(tCombo, { visible: false })
+                    tCombo.getModel().inRange = false;
+                  } else {
+                    graph.updateCombo(tCombo);
+                  }
+                }
+              }
             } else if (!exist && shouldShow) {
               currentEdgeExistMap_1[edge.id] = true;
-              graph.addItem('edge', edge);
+              //graph.addItem('edge', edge);
+              const edgeObject = graph.findById(edge.id); // <---- ADDED
+              graph.showItem(edgeObject); // <---- ADDED
+              edge.inRange = true; // <---- ADDED
+              const source = edgeObject.getSource(); // <---- ADDED
+              const target = edgeObject.getTarget(); // <---- ADDED
+              target.getModel().inRange = true; 
+              source.getModel().inRange = true;
+              graph.showItem(target); // <---- ADDED
+              if (target.getModel().comboId !== undefined) { 
+                const tCombo = graph.findById(target.getModel().comboId);
+                const nodesInCombo = getAllNodesInCombo(tCombo);
+                const visibleNodes = nodesInCombo.filter((node) => node.isVisible())
+                tCombo.getModel().label = visibleNodes.length;
+                if(!tCombo.isVisible()) {
+                  graph.updateItem(tCombo, {visible: true});
+                  tCombo.getModel().inRange = true;
+                } else {
+                  graph.updateCombo(tCombo);
+                }
+              }
+              graph.showItem(source); // <---- ADDED
+              if (source.getModel().comboId !== undefined) { 
+                const sCombo = graph.findById(source.getModel().comboId);
+                const nodesInCombo = getAllNodesInCombo(sCombo);
+                const visibleNodes = nodesInCombo.filter((node) => node.isVisible())
+                sCombo.getModel().label = visibleNodes.length;
+                if(!sCombo.isVisible()) {
+                  graph.updateItem(sCombo, {visible: true});
+                  sCombo.getModel().inRange = true; 
+                } else {
+                  graph.updateCombo(sCombo);
+                }
+              }
+              
             }
           });
         }
-      } else {
+       } else {
         if (filterItemTypes.includes('node')) {
           graph.getNodes().forEach(function (node) {
             var model = node.getModel();
