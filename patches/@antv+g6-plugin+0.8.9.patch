diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
index 1ebc924..a7f60de 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
@@ -39,7 +39,7 @@ interface TimeBarConfig extends IPluginBaseConfig {
     readonly containerCSS?: Object;
     readonly changeData?: boolean;
     rangeChange?: (graph: IGraph, minValue: string, maxValue: string) => void;
-    getDate?: (d: any) => number;
+    getDate?: (d: any) => number[]; //<------
     getValue?: (d: any) => number;
     shouldIgnore?: (itemType: 'node' | 'edge', model: any, dateRage: {
         min: number;
diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.js b/node_modules/@antv/g6-plugin/es/timeBar/index.js
index b07b81f..d550003 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.js
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.js
@@ -101,7 +101,7 @@ var TimeBar = /** @class */function (_super) {
       },
       textStyle: {},
       filterEdge: false,
-      filterItemTypes: ['node'],
+      filterItemTypes: [/* 'node',  */'edge'], /* remove node,  added 'edge' */
       containerCSS: {}
     };
   };
@@ -269,6 +269,61 @@ var TimeBar = /** @class */function (_super) {
     });
     this.set('timebar', timebar);
   };
+
+  function getAllNodesInCombo(combo) {  // ---ADDED
+    let arr = []; // ---ADDED
+    return grabAllNodes(combo, arr); // ---ADDED 
+  }
+
+  function grabAllNodes(combo, array) { // ---ADDED
+    let combos = combo.getCombos();  // ---ADDED
+    let childNodes = combo.getNodes();  // ---ADDED
+    
+    combos.forEach((inCombo) => { array.concat(grabAllNodes(inCombo, array)); }); // ---ADDED
+    childNodes.forEach((node) => { array.push(node); }); // ---ADDED
+    return array;
+  }
+
+  function getAllParents(childCombo, graph) {
+    let arr = []
+    grabParents(childCombo, arr, graph);
+    return arr;
+  }
+
+  function grabParents(combo, array, graph) {
+    if (combo.getModel().parentId === undefined) {
+      return 
+    } else {
+      const parentID = combo.getModel().parentId
+      const parentCombo = graph.findById(parentID);
+      array.push(parentCombo);
+      grabParents(parentCombo, array, graph);
+    }
+  }
+
+  function getHighestVisibleItem(node, graph) {
+    let innermostCombo;
+    if(node.getModel().comboId !== undefined) {
+      innermostCombo = graph.findById(node.getModel().comboId);
+      if (innermostCombo.isVisible()) {
+        return innermostCombo;
+      } else {
+        // run recursion on parent of innermostCombo
+        return getHighestVisibleCombo(innermostCombo, graph);
+      } 
+    } else return node
+    throw 'error at getHighestVisibleItem'
+  } 
+
+  function getHighestVisibleCombo(combo, graph) {
+    if (combo.isVisible()) {
+      return combo
+    } else {
+      const parentCombo = graph.findById(combo.getModel().parentId)
+      return getHighestVisibleCombo(parentCombo, graph)
+    }
+  }
+
   TimeBar.prototype.filterData = function (evt) {
     var _a;
     var value = evt.value;
@@ -331,7 +386,8 @@ var TimeBar = /** @class */function (_super) {
           return currentNodeExistMap_1[node.getID()] = true;
         });
         graph.getEdges().forEach(function (edge) {
-          return currentEdgeExistMap_1[edge.getID()] = true;
+          return currentEdgeExistMap_1[edge.getID()] = edge.isVisible(); // <================ ADDED
+          // return currentEdgeExistMap_1[edge.getID()] = true; // <=================NOT USED
         });
         if (filterItemTypes.includes('node')) {
           originNodes === null || originNodes === void 0 ? void 0 : originNodes.forEach(function (node) {
@@ -342,10 +398,16 @@ var TimeBar = /** @class */function (_super) {
             }));
             var exist = currentNodeExistMap_1[node.id];
             if (exist && !hitRange) {
+              //*** Save the node comboID ***//
+              const comboID = node.comboId; //<=== added
               graph.removeItem(node.id);
+              //***Append back the comboID back to node***//
+              console.log('node removed!:', node); //<=== added
+              node.comboId = comboID; //<=== added
               currentNodeExistMap_1[node.id] = false;
             } else if (!exist && hitRange) {
               graph.addItem('node', node);
+              console.log('node added back:', node); //<=== added
               currentNodeExistMap_1[node.id] = true;
             }
           });
@@ -357,10 +419,12 @@ var TimeBar = /** @class */function (_super) {
             }));
             var exist = !!graph.findById(edge.id);
             if (exist && !shouldShow) {
-              graph.removeItem(edge.id);
+              // graph.removeItem(edge.id);
+              graph.updateItem(graph.findById(edge.id), {visible: false}); 
               currentEdgeExistMap_1[edge.id] = false;
             } else if (!exist && shouldShow) {
-              graph.addItem('edge', edge);
+              //graph.addItem('edge', edge);
+              graph.updateItem(graph.findById(edge.id), {visible: true}); 
               currentEdgeExistMap_1[edge.id] = true;
             } else if (!exist) {
               currentEdgeExistMap_1[edge.id] = false;
@@ -369,24 +433,187 @@ var TimeBar = /** @class */function (_super) {
         }
         if (this.get('filterEdge') || filterItemTypes.includes('edge')) {
           originEdges === null || originEdges === void 0 ? void 0 : originEdges.filter(function (edge) {
-            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
-            var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
+            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date); // <--- NOT USED ANYMORE
+            const dates = edge.date; // <---- ADDED
+            const dateHit = dates.some((date) => (date >= minDate_1 && date <= maxDate_1)); // <---- ADDED
+            var hitRange = /* date >= minDate_1 && date <= maxDate_1 */ dateHit || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
               min: minDate_1,
               max: maxDate_1
             }));
-            var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target];
-            var shouldShow = hitRange && endsExist;
-            var exist = currentEdgeExistMap_1[edge.id];
-            if (exist && !shouldShow) {
-              currentEdgeExistMap_1[edge.id] = false;
-              graph.removeItem(edge.id);
-            } else if (!exist && shouldShow) {
-              currentEdgeExistMap_1[edge.id] = true;
-              graph.addItem('edge', edge);
+            const hitDates = []; // <---- ADDED
+            edge.date.forEach((date) => { // <---- ADDED
+              if(date >= minDate_1 && date <= maxDate_1) hitDates.push(date); // <---- ADDED
+            }); // <---- ADDED
+            graph.findById(edge.id).getModel().frequency = hitDates.length; // <---- ADDED
+            if(edge.id === 'edge2') {
+              console.warn('edge2 frequency inRange', graph.findById(edge.id).getModel().frequency);
             }
+            graph.updateItem(graph.findById(edge.id), { frequency: hitDates.length }); // <---- ADDED
+            const inRangeStatus = dateHit; // <---COUPLE inRange property directly to dateRange, decouple from show/hide item.
+            edge.inRange = inRangeStatus; // <---- ADDED
+            //var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target]; 
+            // var shouldShow = hitRange && endsExist;
+            // var exist = currentEdgeExistMap_1[edge.id]; // NOT USED  // currentEdgeExistMap is set by line 376, by isVisible()! 
+
+            
+            const edgeObject = graph.findById(edge.id);// <---- ADDED
+            const source = edgeObject.getSource(); // <---- ADDED
+            const target = edgeObject.getTarget(); // <---- ADDED
+            const ends = [source, target];
+
+            ends.forEach((node) => {
+              // set inRange status for the 2 nodes of the edge inRange.
+              node.getModel().inRange = inRangeStatus;
+            });
+            
+            //TOGGLE SHOW or HIDE items
+            if (hitRange) {
+
+            } else if (!hitRange) {
+              if (edgeObject.getModel().collapsedByCombo) {
+                // expandCollapse Combo code would have hidden .this edge automatically*
+                // if(source.getModel().comboId !== undefined && target.getModel().comboId !== undefined ||
+                //    source.getModel().comboId === undefined && target.getModel().comboId !== undefined ||
+                //    source.getModel().comboId !== undefined && target.getModel().comboId === undefined) {
+                  // get highest visible item of source and target
+                  const c1 = getHighestVisibleItem(source, graph);
+                  const c2 = getHighestVisibleItem(target, graph);
+
+                  let c1Nodes;
+                  let c1Edges = [];
+                  let c2Nodes;
+                  let c2Edges = [];
+                  if (c1.getType() === 'combo') {
+                    // if c1 is a combo
+                    // get all nodes inside c1 excluding the source of .this edge* that should be hidden
+                    c1Nodes = getAllNodesInCombo(c1);/* .filter(otherNode => otherNode.getID() !== source.getID()); */
+                    // grab all edges that are connected to this highest item
+                    c1Nodes.forEach((node) => {c1Edges = c1Edges.concat(node.getEdges())});
+                  } else {
+                    // if c1 is a node, 
+                    c1Edges = c1Edges.concat(c1.getEdges());
+                  }
+                  
+
+                  if (c2.getType() === 'combo') {
+                    // if c2 is a combo
+                    // get all nodes inside c2 excluding the target of .this edge* that should be hidden
+                    c2Nodes = getAllNodesInCombo(c2); /* .filter(otherNode=> otherNode.getID() !== target.getID()) */
+                    // grab all edges that are connected to this highest item
+                    c2Nodes.forEach((node) => {c2Edges = c2Edges.concat(node.getEdges())});
+                  } else {
+                    // if c2 is a node
+                    c2Edges = c2Edges.concat(c2.getEdges());
+                  }
+                  // FOR PARALLEL EDGES
+                  // 1. are there any other parallel edges between c1 and c2?, based on comparing edges between their nodes inside?
+                  let parallelEdges = [];
+                  for (let i = 0; i < c1Edges.length; i++) {
+                    for(let j = 0; j < c2Edges.length; j++) {
+                      if (c1Edges[i].getID() === c2Edges[j].getID() && 
+                          c1Edges[i].getID() !== edge.id &&
+                          c2Edges[j].getID() !== edge.id /* exclude source or target away */
+                      ) {
+                        parallelEdges.push(c1Edges[i]);
+                      }
+                    }
+                  }
+                  console.warn('parallelEdges =', parallelEdges);
+                  let ttpEdgeCount= 0;
+                  let inRangeEdgeCount = 0;
+                  if (parallelEdges.length > 0) {
+                    for(let i = 0; i < parallelEdges.length; i++) {
+                      if (parallelEdges[i].getModel().ttp) {
+                        ttpEdgeCount++
+                      }
+                      if(parallelEdges[i].getModel().date.some((day) => (day >= minDate_1 && day <= maxDate_1))) {
+                        inRangeEdgeCount++
+                      }
+                    }
+                  }
+                  // 1.1 Handling VE for Parallel Edges
+                  // grab the VE of .this edge
+                  const c1VEdges = c1.getEdges();
+                  for (let i = c1VEdges; i < c1VEdges.length; i++) {
+                    if (c1VEdges[i].getSource().getID() === c1.getID() && c1VEdges[i].getTarget().getID() === c2.getID() && 
+                        c1VEdges[i].getSource().getID() === c2.getID() && c1VEdges[i].getTarget().getID() === c1.getID()
+                      ) {
+                      // when the VE has no more standard edges inRange
+                      if(inRangeEdgeCount === 0) {
+                        // HIDE VE of .this edge if all its edges are no longer in range
+                        graph.removeItem(c1VEdges[i]);
+                      } else {
+                        if (ttpEdgeCount === 0) {
+                          // if VE still has remaining edges inRange but they are all not TTP, 
+                          graph.updateItem(c1VEdges[i], {ttp: false});
+                        }
+                      }
+                    }
+                  }
+
+                // }
+              } else if (!edgeObject.getModel().collapsedByCombo || edgeObject.getModel().collapsedByCombo === undefined) {
+                graph.updateItem(edgeObject, {visible: false}); // <---- hideItem, not removeItem!
+                // HIDE linked nodes & combos which are !inRange
+                ends.forEach((node) => {
+                  const nodeEdges = node.getEdges();
+                  let edgeScore = 0;
+                  nodeEdges.forEach((edge) => {
+                    if(edge.isVisible()) edgeScore++;
+                  });
+                  if(edgeScore === 0) {
+                    // if all of the nodes edges !isVisible(), hide node.
+                    graph.updateItem(node, {visible: false});
+                    // from node, we update the combos, if any,
+                    if(node.getModel().comboId !== undefined) {
+                      const combo = graph.findById(node.getModel().comboId);
+                      const nodesInCombo = getAllNodesInCombo(combo);
+                      // set combo's inRange property based on whether nodes inside are inRange (not visible)
+                      const inRangeNodes = nodesInCombo.filter((node) => node.getModel().inRange);
+                      if(inRangeNodes.length === 0){
+                        combo.getModel().inRange = false;
+                      } else {
+                        combo.getModel().inRange = true;
+                      }
+                      // set combo's visibility according to whether the nodes inside are still inRange.
+                      // we don't use visible as combo can still be collapsed
+                      combo.getModel().label = inRangeNodes.length;
+                      if(combo.getModel().label === 0 && combo.isVisible()) {
+                        // HIDE the combo
+                        graph.updateItem(combo, { visible: false });
+                        if(combo.getModel().parentId !== undefined) {
+                          // if the combo is the only child, its parents have to be hidden also. 
+                          const parents = getAllParents(combo, graph);
+                          parents.forEach((parent)=>{
+                            const childNodes = parent.getNodes();
+                            const childCombos = parent.getCombos();
+                            const inRangeNodes_p = childNodes.filter((cNode) => {cNode.getModel().inRange});
+                            const inRangeCombos_p = childCombos.filter((cCombo) => {cCombo.getModel().inRange});
+                            if(inRangeNodes_p.length === 0 && inRangeCombos_p.length === 0) {
+                              // HIDE parents and ancestor combos
+                              graph.updateItem(parent, {visible:false});
+                            }
+                          });
+                        }
+                      } else {
+                        // only update the node count of the combo. 
+                        graph.updateCombo(combo);
+                      }
+                    }                
+                  }
+                })
+              } else if (edgeObject.getModel().collapsedByCombo === undefined) {
+
+              } else if (edgeObject.getModel().collapsedByCombo === null){
+                // if edgeObject.getModel().collapsedByCombo is a null or void value?
+
+              }
+            }
+            
           });
+         
         }
-      } else {
+       } else {
         if (filterItemTypes.includes('node')) {
           graph.getNodes().forEach(function (node) {
             var model = node.getModel();
