diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
index 1ebc924..a7f60de 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.d.ts
@@ -39,7 +39,7 @@ interface TimeBarConfig extends IPluginBaseConfig {
     readonly containerCSS?: Object;
     readonly changeData?: boolean;
     rangeChange?: (graph: IGraph, minValue: string, maxValue: string) => void;
-    getDate?: (d: any) => number;
+    getDate?: (d: any) => number[]; //<------
     getValue?: (d: any) => number;
     shouldIgnore?: (itemType: 'node' | 'edge', model: any, dateRage: {
         min: number;
diff --git a/node_modules/@antv/g6-plugin/es/timeBar/index.js b/node_modules/@antv/g6-plugin/es/timeBar/index.js
index b07b81f..82cd350 100644
--- a/node_modules/@antv/g6-plugin/es/timeBar/index.js
+++ b/node_modules/@antv/g6-plugin/es/timeBar/index.js
@@ -101,7 +101,7 @@ var TimeBar = /** @class */function (_super) {
       },
       textStyle: {},
       filterEdge: false,
-      filterItemTypes: ['node'],
+      filterItemTypes: [/* 'node',  */'edge'], /* remove node,  added 'edge' */
       containerCSS: {}
     };
   };
@@ -269,6 +269,38 @@ var TimeBar = /** @class */function (_super) {
     });
     this.set('timebar', timebar);
   };
+
+  function getAllNodesInCombo(combo) {  // ---ADDED
+    let arr = []; // ---ADDED
+    return grabAllNodes(combo, arr); // ---ADDED 
+  }
+
+  function grabAllNodes(combo, array) { // ---ADDED
+    let combos = combo.getCombos();  // ---ADDED
+    let childNodes = combo.getNodes();  // ---ADDED
+    
+    combos.forEach((inCombo) => { array.concat(grabAllNodes(inCombo, array)); }); // ---ADDED
+    childNodes.forEach((node) => { array.push(node); }); // ---ADDED
+    return array;
+  }
+
+  function getAllParents(childCombo, graph) {
+    let arr = []
+    grabParents(childCombo, arr, graph);
+    return arr;
+  }
+
+  function grabParents(combo, array, graph) {
+    if (combo.getModel().parentId === undefined) {
+      return 
+    } else {
+      const parentID = combo.getModel().parentId
+      const parentCombo = graph.findById(parentID);
+      array.push(parentCombo);
+      grabParents(parentCombo, array, graph);
+    }
+  }
+
   TimeBar.prototype.filterData = function (evt) {
     var _a;
     var value = evt.value;
@@ -331,7 +363,8 @@ var TimeBar = /** @class */function (_super) {
           return currentNodeExistMap_1[node.getID()] = true; 
         });
         graph.getEdges().forEach(function (edge) {
-          return currentEdgeExistMap_1[edge.getID()] = true;
+          return currentEdgeExistMap_1[edge.getID()] = edge.isVisible(); // <================ ADDED
+          // return currentEdgeExistMap_1[edge.getID()] = true; // <=================NOT USED
         });
         if (filterItemTypes.includes('node')) {
           originNodes === null || originNodes === void 0 ? void 0 : originNodes.forEach(function (node) {
@@ -342,10 +375,16 @@ var TimeBar = /** @class */function (_super) {
             }));
             var exist = currentNodeExistMap_1[node.id];
             if (exist && !hitRange) {
+              //*** Save the node comboID ***//
+              const comboID = node.comboId; //<=== added
               graph.removeItem(node.id);
+              //***Append back the comboID back to node***//
+              console.log('node removed!:', node); //<=== added
+              node.comboId = comboID; //<=== added
               currentNodeExistMap_1[node.id] = false;
             } else if (!exist && hitRange) {
               graph.addItem('node', node);
+              console.log('node added back:', node); //<=== added
               currentNodeExistMap_1[node.id] = true;
             }
           });
@@ -369,24 +408,132 @@ var TimeBar = /** @class */function (_super) {
         }
         if (this.get('filterEdge') || filterItemTypes.includes('edge')) {
           originEdges === null || originEdges === void 0 ? void 0 : originEdges.filter(function (edge) {
-            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
-            var hitRange = date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
+            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date); // <--- NOT USED ANYMORE
+            const dates = edge.date; // <---- ADDED
+            const dateHit = dates.some((date) => (date >= minDate_1 && date <= maxDate_1)); // <---- ADDED
+            var hitRange = /* date >= minDate_1 && date <= maxDate_1 */ dateHit || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1('edge', edge, {
               min: minDate_1,
               max: maxDate_1
             }));
+            const hitDates = []; // <---- ADDED
+            edge.date.forEach((date) => { // <---- ADDED
+              if(date >= minDate_1 && date <= maxDate_1) hitDates.push(date); // <---- ADDED
+            }); // <---- ADDED
+            graph.findById(edge.id).getModel().frequency = hitDates.length; // <---- ADDED
+            graph.updateItem(graph.findById(edge.id), { // <---- ADDED
+              frequency: hitDates.length  // <---- ADDED
+            }); // <---- ADDED
+            const inRangeStatus = dateHit; // <---COUPLE inRange property directly to dateRange, decouple from show/hide item.
+            edge.inRange = inRangeStatus; // <---- ADDED
             var endsExist = currentNodeExistMap_1[edge.source] && currentNodeExistMap_1[edge.target];
             var shouldShow = hitRange && endsExist;
             var exist = currentEdgeExistMap_1[edge.id];
+            
+            const edgeObject = graph.findById(edge.id);// <---- ADDED
+            const source = edgeObject.getSource(); // <---- ADDED
+            const target = edgeObject.getTarget(); // <---- ADDED
+            const ends = [source, target];
+            // set inRange status the 2 nodes of the edge inRange.
+            ends.forEach((node) => {
+              node.getModel().inRange = inRangeStatus;
+            });
+            
             if (exist && !shouldShow) {
               currentEdgeExistMap_1[edge.id] = false;
-              graph.removeItem(edge.id);
+              //graph.removeItem(edge.id);
+              graph.hideItem(edgeObject); // <---- change we don't remove the item.
+              ends.forEach((node) => {
+                const nodeEdges = node.getEdges();
+                let edgeScore = 0;
+                nodeEdges.forEach((edge) => {
+                  if(edge.isVisible()) {
+                    edgeScore++;
+                  }
+                });
+                if(edgeScore === 0) {
+                  // if all of the nodes edges have isVisible() = false, hide node.
+                  graph.hideItem(node);
+                }
+                // from node, we update the combos, if any,
+                if(node.getModel().comboId !== undefined) {
+                  const combo = graph.findById(node.getModel().comboId);
+                  const nodesInCombo = getAllNodesInCombo(combo);
+                  // set combo's inRange property based on whether nodes inside are inRange (not visible)
+                  const inRangeNodes = nodesInCombo.filter((node) => node.getModel().inRange);
+                  if(inRangeNodes.length === 0){
+                    combo.getModel().inRange = false;
+                  } else {
+                    combo.getModel().inRange = true;
+                  }
+                  // set combo's visibility according to whether the nodes inside are still visible.
+                  const visibleNodes = nodesInCombo.filter((node) => node.isVisible());
+                  combo.getModel().label = visibleNodes.length;
+                  if(combo.getModel().label === 0 && combo.isVisible()) {
+                    graph.updateItem(combo, { visible: false });
+                    if(combo.getModel().parentId !== undefined) {
+                      // if the combo is the only child, its parents have to be hidden also. 
+                      const parents = getAllParents(combo, graph);
+                      parents.forEach((parent)=>{
+                        const childNodes = parent.getNodes();
+                        const childCombos = parent.getCombos();
+                        const visibleNodes = childNodes.filter((cNode) => {cNode.isVisible()});
+                        const visibleCombos = childCombos.filter((cCombo) => {cCombo.isVisible()});
+                        if(visibleNodes.length === 0 && visibleCombos.length === 0) {
+                          graph.updateItem(parent, {visible:false});
+                        }
+                      });
+                    }
+                  } else {
+                    graph.updateCombo(combo);
+                  }
+                }                
+              })
             } else if (!exist && shouldShow) {
               currentEdgeExistMap_1[edge.id] = true;
-              graph.addItem('edge', edge);
+              //graph.addItem('edge', edge);
+              const edgeObject = graph.findById(edge.id); // <---- ADDED
+              graph.showItem(edgeObject); // <---- ADDED
+              ends.forEach((node) => {
+                // show node(end) connected to the edge that's showing. 
+                graph.showItem(node);
+                // update combo related to the nodes connected by the edge
+                if (node.getModel().comboId !== undefined) {
+                  const combo = graph.findById(node.getModel().comboId);
+                  const nodesInCombo = getAllNodesInCombo(combo);
+                  // setting combo's inRange property based on whether nodes inside are still inRange
+                  const inRangeNodes = nodesInCombo.filter((node) => node.getModel().inRange);
+                  if(inRangeNodes.length === 0){
+                    combo.getModel().inRange = false;
+                  } else {
+                    combo.getModel().inRange = true;
+                  }
+                  // set combo's visibility according to whether there are nodes that are still visible.
+                  const visibleNodes = nodesInCombo.filter((node) => node.isVisible());
+                  combo.getModel().label = visibleNodes.length;
+                  if(!combo.isVisible()) {
+                    graph.update(combo, {visible: true});
+                    if(combo.getModel().parentId !== undefined) {
+                      // if the combo has parents, and they would have to made visible.  
+                      const parents = getAllParents(combo, graph);
+                      parents.forEach((parent)=>{
+                          graph.updateItem(parent, {visible: true});
+                      });
+                    }
+                  } else {
+                    graph.updateCombo(combo);
+                  }
+                }
+              });
+            }
+            const combo4 = graph.findById('combo1');
+            if(combo4.getModel().inRange !== undefined) {
+              console.warn('combo4 inRange =', combo4.getModel().inRange);
+              console.warn('combo1 parents =', getAllParents(graph.findById('combo1'), graph));
+              console.warn('combo4 parents =', getAllParents(graph.findById('combo4'), graph));
             }
           });
         }
-      } else {
+       } else {
         if (filterItemTypes.includes('node')) {
           graph.getNodes().forEach(function (node) {
             var model = node.getModel();
